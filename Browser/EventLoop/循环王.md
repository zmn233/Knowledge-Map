## 循环王：`javascript` 中的 `EventLoop`

 `javascript `是一个单线程语言，为了防止程序发生阻塞， `javascript `中既有异步也有同步。

 `javascript` 整体的执行机制叫做 `Event-loop` 事件循环。将  `javascript` 的任务分为**宏任务(`MacroTask`)**以及**微任务(`MicroTask`)**。

###### 宏任务

`script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见[`MDN`](https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetImmediate)）、`I/O`、`UI Rendering`。

###### 微任务

`Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver`

网上有很多关于时间循环的图片，随便找一张放在这里![](https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

事件循环的顺序，决定了JavaScript代码的执行顺序。

- 它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。
- 直到执行完所有同步代码，调用栈清空(只剩全局)，然后执行**所有的**micro-task。
- 当**所有**可执行的micro-task执行完毕之后。循环再次从macro-task开始，直到其中一个任务执行完毕，然后再执行所有的micro-task，这样一直循环下去。

> 注：在同一个循环中被加入队列的任务，会先等该队列执行结束再执行后面的队列
>
> ​    比如说, `setTimeOut(), setImmediate(), setTimeOut(), setImmediate()`, 会将两个 `timeOut` 放入其对应的任务队列中,两个 immediate 放入另一个队列中，因为 `timeOut` 先定义，会首先执行到 `timeOut`
>
> ​    在执行到 `timeOut` 队列时，会先将两个 `timeOut` 执行结束，再检查微任务队列中是否有任务，执行完了才执行 immediate 
>
> ​    但是！如果我第一个 `setTimeout` 事件中产生了待执行的微任务，那么会首先执行这些微任务，而不是等待 `setTimeout` 队列执行完成！
>
> ​    也就是说 宏任务的执行是按照队列顺序来的，但是每执行完成一个宏任务（而不是宏任务队列），都要去检查一下是否有待执行的微任务，有的话就要执行这些微任务  
>
> ​    还有就是，当我们在微任务的执行过程中又继续产生了微任务，比如说`then`方法里又定义了 `promise` 的`then` 方法，会一直执行到所有的 then 结束，才去执行宏任务，哪怕这个宏任务是跟第一个 `then` 一起定义的。想想也没什么解释不通的地方，理解“清空队列”这四个字很重要了



`ES7` 中的 `async` 以及 `await` 为 `promise` 语法糖，也会牵扯到事件循环的问题，下面就来看看这两者的用法吧。

#### `async, await`

`async` 表示异步，它会将函数的返回值包装为 `promise` 之后进行返回。如果返回值本身是一个 `promise` 则直接返回该 `promise`，否则调用 `Promise.resolve()`。

`await` 一般放在 `async` 函数中，**从右到左**执行，表示右侧表达式会返回一个 `promise`。它会等待右侧 `promise` 执行完成，并将其 `resolve` 的值返回出来。

下面看一个示例：

```javascript
// 1. 首先走到这里打印出 script start
console.log('script start')
async function async1() {
    // 3. async1 函数第一行是一个 await + 函数调用，因为await 会等待右边表达式执行结束，因此我们现在来执行 async2
  await async2()
  // 5. 代码回到 async1，await 表示右边会返回一个 promise 对象，而这个地方 async 返回的是 undefined，则会调用 Promise.resolve(undefined) 将其包装为一个 promise 对象并返回。我自己理解，这里执行的逻辑是 
// Promise.resolve(undefined).then((undefined) -> {
//    console.log('async1 end')
// })
  // 因此这个地方相当于将 async1 里剩下的同步代码放到了 promise 的 then 中，因此会比下面 promise 中的 then 先执行。
    
  // 9. script 代码执行完成之后，回到了这里，打印 async1 end
  console.log('async1 end')
}
// 4. 执行 async2，打印 async2 end
async function async2() {
  console.log('async2 end') 
}
// 2.然后执行 async1 函数
async1()
// 6. 函数执行到这里，将 setTimeout 回调函数放进宏任务执行队列
setTimeout(function() {
  // 12. 打印 setTimeout，结束。
  console.log('setTimeout')
}, 0)
// 7. 继续执行，打印出 Promise，将 then 方法放进微任务队列
new Promise(resolve => {
  console.log('Promise')
  resolve()
})
  // 10. 打印 promise1
  .then(function() {
    console.log('promise1')
  })
  // 11. 打印 promise2，这个地方具体可见 eventLoop.js。微任务队列要清空之后才执行宏任务，因此哪怕我实在微任务中生成了微任务，也要一直执行下去直到队列清空
  .then(function() {
    console.log('promise2')
  })
// 8. 打印出 script end
console.log('script end')
/*
script start
async2 end
Promise
script end
async1 end
promise1
promise2
setTimeout
* */
```

说到这里，你有没有想过，宏任务与微任务的队列是由什么在控制呢，任务的切换是怎么进行的呢？在回答这个问题之前，我们首先来讲一讲线程和进程。

#### 线程与进程

计算机的核心是`CPU`，它承担了所有的计算任务。它像一座随时都在运行的工厂，但是工厂供电有限，一次只能供给一个车间使用，这个车间就是**进程**。换句话说，`CPU` 在任一时刻总是运行一个进程，其他进程属于非运行状态。`CPU`使用时间片轮转进度算法来实现同时运行多个进程。

一个车间里，可以有很多工人，共享车间所有的资源，他们协同完成一个任务。**线程**就好比车间里的工人，一个进程可以包括多个线程，多个线程共享进程资源。

总结一下，`CPU` 与进程和线程的关系如下：

- 进程是`cpu`资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是`cpu`调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- 不同进程之间也可以通信，不过代价较大
- 单线程与多线程，都是指在一个进程内的单和多

#### 浏览器是多进程的

每个进程各司其职。主要分类如下：

1. 主进程 

   - 协调控制其他子进程（创建、销毁）
   - 浏览器界面显示，用户交互，前进、后退、收藏
   - 将渲染进程得到的内存中的`Bitmap`，绘制到用户界面上
   - 处理不可见操作，网络请求，文件访问等

2. 第三方插件进程 

   - 每种类型的插件对应一个进程，仅当使用该插件时才创建

3. `GPU`进程 

   - 用于`3D`绘制等

4. **渲染进程**，就是我们说的**浏览器内核**

   - 负责页面渲染，脚本执行，事件处理等
   - 每个tab页一个渲染进程

   我们进行的前端操作，都是由渲染进程控制的。

   #### 渲染进程

   渲染进程下包含多线程：

   1. `GUI` 渲染线程

      - 负责渲染页面，布局和绘制
      - 页面需要重绘和回流时，该线程就会执行
      - 与`JS`引擎线程互斥，防止渲染结果不可预期

   2. `JS`引擎线程

      - 负责处理解析和执行`javascript`脚本程序
      - 只有一个`JS`引擎线程（单线程）
      - 与GUI渲染线程互斥，防止渲染结果不可预期

   3. 事件触发线程

      - 用来控制事件循环（鼠标点击、`setTimeout`、`ajax`等）
      - 当事件满足触发条件时，将事件放入到`JS`引擎所在的执行队列中

   4. 定时触发器线程

      - `setInterval`与`setTimeout`所在的线程
      - 定时任务并不是由`JS`引擎计时的，是由定时触发线程来计时的
      - 计时完毕后，通知事件触发线程

   5. 异步`http`请求线程

      - 浏览器有一个单独的线程用于处理`AJAX`请求
      - 当请求完成时，若有回调函数，通知事件触发线程

      **`GUI`渲染线程与`JS`引擎线程是互斥的**，这是因为`JS`可以操作`DOM`，所以为了防止渲染出现不可预期的结果，`JS`引擎线程执行时`GUI`渲染线程会挂起。

      下面用一个示例来解释这几个线程的工作顺序：

      ```javascript
      let timerCallback = function() {
        console.log('wait one second');
      };
      let httpCallback = function() {
        console.log('get server data success');
      }
      
      // 同步任务
      console.log('hello');
      // 同步任务
      // 通知定时器线程 1s 后将 timerCallback 交由事件触发线程处理
      // 1s 后事件触发线程将 timerCallback 加入到事件队列中
      setTimeout(timerCallback,1000);
      // 同步任务
      // 通知异步http请求线程发送网络请求，请求成功后将 httpCallback 交由事件触发线程处理
      // 请求成功后事件触发线程将 httpCallback 加入到事件队列中
      $.get('www.xxxx.com',httpCallback);
      // 同步任务
      console.log('world');
      //...
      // 所有同步任务执行完后
      // 询问事件触发线程在事件队列中是否有需要执行的回调函数
      // 如果没有，一直询问，直到有为止
      // 如果有，将回调事件加入执行栈中，开始执行回调代码
      ```

      看到这里你又不明白了，那上面介绍的宏任务和微任务又是什么意思呢？为啥没有控制这两个任务的线程，下面我就继续用代码来解释。

      ```javascript
      // 同步任务
      // 1. 通知定时器线程 0 秒后将回调函数交由 事件触发函数 处理
      setTimeout(() => {
          // 3. 找到事件队列中的回调函数，放到调用栈中，同步执行
          console.log(1)
          // 4. Promise.then 为微任务，创建微任务队列，将回调函数放入其中
          Promise.resolve(3).then(data => 
             // 5. 执行微任务
             console.log(data)
          )
      }, 0)
      // 同步任务
      // 2. 通知定时器线程 0 秒后将回调函数交由 事件触发函数 处理
      // 此时事件队列中有两个回调函数
      setTimeout(() => {
          // 6. 微任务执行完毕，继续执行任务队列中任务
          console.log(2)
      }, 0)
      
      ```

      （突然被自己脑子里的问题打乱了思路，接下来还要看看关于浏览器渲染的文章才可以解答疑惑）

      问题主要如下：

      1. GUI线程是在哪里运行（真的是执行一次宏任务之后吗？）
         - 有一个 16.7 ms 的规定，浏览器每 16.7 ms 刷新一次，对用户体验较好（不过每个浏览器规定都不同）
      2. 定时器线程会将定时器的回调函数放入事件队列，而每一个回调函数（也就是一个宏任务）执行结束后都会去执行所有微任务，同一API（比如setImmediate）构成的队列会同时执行，也就是说按照 setTimeout, setImmediate, setTimeout, setImmediate 顺序注册的回调函数，setTimeout会先于 SetImmediate 执行。这是不是说明这两者是放在不同事件队列里的，否则一个队列是怎么做到的呢？
         - 经过测试，宏任务执行顺序并不是我原来想的那样，这个问题也就不是问题了（捂脸emoji）。
      3. script 中 async 和 defer 区别？
         - ![](https://pic4.zhimg.com/v2-909c198b7ef020ad8529cfa97f4ffd6f_r.jpg)

