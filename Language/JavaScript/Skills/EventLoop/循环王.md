## 循环王：`javascript` 中的 `EventLoop`

 `javascript `是一个单线程语言，为了防止程序发生阻塞， `javascript `中既有异步也有同步。

 `javascript` 整体的执行机制叫做 `Event-loop` 事件循环。将  `javascript` 的任务分为**宏任务(`MacroTask`)**以及**微任务(`MicroTask`)**。

###### 宏任务

`script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见[`MDN`](https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetImmediate)）、`I/O`、`UI Rendering`。

###### 微任务

`Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver`

网上有很多关于时间循环的图片，随便找一张放在这里![](https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

事件循环的顺序，决定了JavaScript代码的执行顺序。

- 它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。
- 直到执行完所有同步代码，调用栈清空(只剩全局)，然后执行**所有的**micro-task。
- 当**所有**可执行的micro-task执行完毕之后。循环再次从macro-task开始，直到其中一个任务执行完毕，然后再执行所有的micro-task，这样一直循环下去。

> 注：在同一个循环中被加入队列的任务，会先等该队列执行结束再执行后面的队列
>
> ​    比如说, `setTimeOut(), setImmediate(), setTimeOut(), setImmediate()`, 会将两个 `timeOut` 放入其对应的任务队列中,两个 immediate 放入另一个队列中，因为 `timeOut` 先定义，会首先执行到 `timeOut`
>
> ​    在执行到 `timeOut` 队列时，会先将两个 `timeOut` 执行结束，再检查微任务队列中是否有任务，执行完了才执行 immediate 
>
> ​    但是！如果我第一个 `setTimeout` 事件中产生了待执行的微任务，那么会首先执行这些微任务，而不是等待 `setTimeout` 队列执行完成！
>
> ​    也就是说 宏任务的执行是按照队列顺序来的，但是每执行完成一个宏任务（而不是宏任务队列），都要去检查一下是否有待执行的微任务，有的话就要执行这些微任务  
>
> ​    还有就是，当我们在微任务的执行过程中又继续产生了微任务，比如说`then`方法里又定义了 `promise` 的`then` 方法，会一直执行到所有的 then 结束，才去执行宏任务，哪怕这个宏任务是跟第一个 `then` 一起定义的。想想也没什么解释不通的地方，理解“清空队列”这四个字很重要了



`ES7` 中的 `async` 以及 `await` 为 `promise` 语法糖，也会牵扯到事件循环的问题，下面就来看看这两者的用法吧。

#### `async, await`

`async` 表示异步，它会将函数的返回值包装为 `promise` 之后进行返回。如果返回值本身是一个 `promise` 则直接返回该 `promise`，否则调用 `Promise.resolve()`。

`await` 一般放在 `async` 函数中，**从右到左**执行，表示右侧表达式会返回一个 `promise`。它会等待右侧 `promise` 执行完成，并将其 `resolve` 的值返回出来。

下面看一个示例：

```javascript
// 1. 首先走到这里打印出 script start
console.log('script start')
async function async1() {
    // 3. async1 函数第一行是一个 await + 函数调用，因为await 会等待右边表达式执行结束，因此我们现在来执行 async2
  await async2()
  // 5. 代码回到 async1，await 表示右边会返回一个 promise 对象，而这个地方 async 返回的是 undefined，则会调用 Promise.resolve(undefined) 将其包装为一个 promise 对象并返回。我自己理解，这里执行的逻辑是 
// Promise.resolve(undefined).then((undefined) -> {
//    console.log('async1 end')
// })
  // 因此这个地方相当于将 async1 里剩下的同步代码放到了 promise 的 then 中，因此会比下面 promise 中的 then 先执行。
    
  // 9. script 代码执行完成之后，回到了这里，打印 async1 end
  console.log('async1 end')
}
// 4. 执行 async2，打印 async2 end
async function async2() {
  console.log('async2 end') 
}
// 2.然后执行 async1 函数
async1()
// 6. 函数执行到这里，将 setTimeout 回调函数放进宏任务执行队列
setTimeout(function() {
  // 12. 打印 setTimeout，结束。
  console.log('setTimeout')
}, 0)
// 7. 继续执行，打印出 Promise，将 then 方法放进微任务队列
new Promise(resolve => {
  console.log('Promise')
  resolve()
})
  // 10. 打印 promise1
  .then(function() {
    console.log('promise1')
  })
  // 11. 打印 promise2，这个地方具体可见 eventLoop.js。微任务队列要清空之后才执行宏任务，因此哪怕我实在微任务中生成了微任务，也要一直执行下去直到队列清空
  .then(function() {
    console.log('promise2')
  })
// 8. 打印出 script end
console.log('script end')
/*
script start
async2 end
Promise
script end
async1 end
promise1
promise2
setTimeout
* */
```

