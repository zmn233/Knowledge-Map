## 循环王

 `javascript `是一个单线程语言，为了防止程序发生阻塞， `javascript `中既有异步也有同步。

 `javascript` 整体的执行机制叫做 `Event-loop` 事件循环。其中将  `javascript` 的任务分为**宏任务(`MacroTask`)**以及**微任务(`MicroTask`)**。

###### 宏任务

`script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见[`MDN`](https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetImmediate)）、`I/O`、`UI Rendering`。

###### 微任务

`Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver`

网上有很多关于时间循环的图片，随便找一张放在这里![](https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行**所有的**micro-task。当**所有**可执行的micro-task执行完毕之后。循环再次从macro-task开始，直到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。

`ES7` 中的 `async` 以及 `await` 为 `promise` 语法糖，也会牵扯到事件循环的问题，下面就来看看这两者的用法吧。

#### `async, await`

`async` 表示异步，它会将函数的返回值包装为 `promise` 之后进行返回。如果返回值本身是一个 `promise` 则直接返回该 `promise`，否则调用 `Promise.resolve()`。

`await` 一般放在 `async` 函数中，**从右到左**执行，表示右侧表达式会返回一个 `promise`。它会等待右侧 `promise` 执行完成，并将其 `resolve` 值返回出来。

下面看一个示例：

```javascript
// 1. 首先走到这里打印出 script start
console.log('script start')
// 3. async1 函数第一行是一个 await + 函数调用，因为await 会等待右边表达式执行结束，因此我们现在来执行 async2
async function async1() {
  await async2()
  // 5. 代码回到 async1，await 表示右边会返回一个 promise 对象，而这个地方 async 返回的是 undefined，则会调用 Promise.resolve() 将其包装为一个 promise 对象并返回。我自己理解，这里执行的逻辑是 
// new Promise((resolve) => {
//    resolve(undefined)
// }).then((undefined) -> {
//    console.log('async1 end')
// })
  // 因此这个地方相当于将 async1 里剩下的同步代码放到了 promise 的 then 中，因此会比下面 promise 中的 then 先执行。
    
  // 9. script 代码执行完成之后，回到了这里，打印 async1 end
  console.log('async1 end')
}
// 4. 执行 async2，打印 async2 end
async function async2() {
  console.log('async2 end') 
}
// 2.然后执行 async1 函数
async1()
// 6. 函数执行到这里，将 setTimeout 放进宏任务执行队列
setTimeout(function() {
  // 12. 打印 setTimeout，结束。
  console.log('setTimeout')
}, 0)
// 7. 继续执行，打印出 Promise，将 then 方法放进微任务队列
new Promise(resolve => {
  console.log('Promise')
  resolve()
})
  // 10. 打印 promise1
  .then(function() {
    console.log('promise1')
  })
  // 11. 打印 promise2，这个地方具体可见 eventLoop.js。微任务队列要清空之后才执行宏任务，因此哪怕我实在微任务中生成了微任务，也要一直执行下去直到队列清空
  .then(function() {
    console.log('promise2')
  })
// 8. 打印出 script end
console.log('script end')
/*
script start
async2 end
Promise
script end
async1 end
promise1
promise2
setTimeout
* */
```

